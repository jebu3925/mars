import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import {
  getTasks,
  createTask,
  updateTask,
  deleteTask,
  getTaskStats,
  Task
} from '@/lib/supabase';
import { taskCreateSchema, taskUpdateSchema, TASK_STATUSES, TASK_PRIORITIES } from '@/lib/validations';
import { requireAuth, isAuthError } from '@/lib/apiAuth';

/**
 * GET /api/tasks
 * Fetch tasks with optional filters
 *
 * Query params:
 * - contractId: Filter by contract UUID
 * - contractSalesforceId: Filter by Salesforce ID
 * - status: Filter by status (pending, in_progress, completed, cancelled)
 * - assignee: Filter by assignee email
 * - stats: If 'true', return task statistics instead of task list
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    // Check if requesting stats
    if (searchParams.get('stats') === 'true') {
      const stats = await getTaskStats();
      return NextResponse.json(stats);
    }

    // Get filters from query params
    const filters: {
      contractId?: string;
      contractSalesforceId?: string;
      status?: string;
      assigneeEmail?: string;
    } = {};

    const contractId = searchParams.get('contractId');
    if (contractId) filters.contractId = contractId;

    const contractSalesforceId = searchParams.get('contractSalesforceId');
    if (contractSalesforceId) filters.contractSalesforceId = contractSalesforceId;

    const status = searchParams.get('status');
    if (status) filters.status = status;

    const assignee = searchParams.get('assignee');
    if (assignee) filters.assigneeEmail = assignee;

    const tasks = await getTasks(filters);

    return NextResponse.json({ tasks });
  } catch (error) {
    console.error('Error in GET /api/tasks:', error);
    return NextResponse.json({ error: 'Failed to fetch tasks' }, { status: 500 });
  }
}

/**
 * POST /api/tasks
 * Create a new task
 *
 * Body:
 * - title: string (required)
 * - description: string (optional)
 * - status: 'pending' | 'in_progress' | 'completed' | 'cancelled' (default: 'pending')
 * - priority: 'low' | 'medium' | 'high' | 'urgent' (default: 'medium')
 * - contractId: UUID (optional)
 * - contractSalesforceId: string (optional)
 * - contractName: string (optional)
 * - contractStage: string (optional)
 * - dueDate: ISO date string (optional)
 * - assigneeEmail: string (optional)
 */
export async function POST(request: NextRequest) {
  try {
    // Verify user is authenticated
    const authResult = await requireAuth(request);
    if (isAuthError(authResult)) {
      return authResult;
    }

    const body = await request.json();

    // Validate with Zod schema
    const parseResult = taskCreateSchema.safeParse(body);
    if (!parseResult.success) {
      return NextResponse.json({
        error: 'Validation failed',
        details: parseResult.error.issues.map(e => `${e.path.join('.')}: ${e.message}`),
      }, { status: 400 });
    }

    const validated = parseResult.data;

    // Map camelCase to snake_case for database
    const task: Omit<Task, 'id' | 'created_at' | 'updated_at'> = {
      title: validated.title.trim(),
      description: validated.description?.trim(),
      status: validated.status,
      priority: validated.priority,
      contract_id: validated.contractId,
      contract_salesforce_id: validated.contractSalesforceId,
      contract_name: validated.contractName,
      contract_stage: validated.contractStage,
      due_date: validated.dueDate || undefined,
      assignee_email: validated.assigneeEmail || undefined,
      is_auto_generated: validated.isAutoGenerated,
      task_template_id: validated.taskTemplateId,
    };

    const createdTask = await createTask(task);

    if (!createdTask) {
      return NextResponse.json({ error: 'Failed to create task' }, { status: 500 });
    }

    return NextResponse.json({ task: createdTask }, { status: 201 });
  } catch (error) {
    console.error('Error in POST /api/tasks:', error);
    return NextResponse.json({ error: 'Failed to create task' }, { status: 500 });
  }
}

/**
 * PATCH /api/tasks
 * Update an existing task
 *
 * Body:
 * - id: string (required) - Task ID to update
 * - ...fields to update (same as POST)
 */
export async function PATCH(request: NextRequest) {
  try {
    // Verify user is authenticated
    const authResult = await requireAuth(request);
    if (isAuthError(authResult)) {
      return authResult;
    }

    const body = await request.json();

    // Validate with Zod schema
    const parseResult = taskUpdateSchema.safeParse(body);
    if (!parseResult.success) {
      return NextResponse.json({
        error: 'Validation failed',
        details: parseResult.error.issues.map(e => `${e.path.join('.')}: ${e.message}`),
      }, { status: 400 });
    }

    const validated = parseResult.data;
    const { id, ...updates } = validated;

    // Build updates object with snake_case keys for database
    const taskUpdates: Partial<Task> = {};
    if (updates.title !== undefined) taskUpdates.title = updates.title.trim();
    if (updates.description !== undefined) taskUpdates.description = updates.description?.trim();
    if (updates.status !== undefined) taskUpdates.status = updates.status;
    if (updates.priority !== undefined) taskUpdates.priority = updates.priority;
    if (updates.dueDate !== undefined) taskUpdates.due_date = updates.dueDate || undefined;
    if (updates.assigneeEmail !== undefined) taskUpdates.assignee_email = updates.assigneeEmail || undefined;
    if (updates.completedAt !== undefined) taskUpdates.completed_at = updates.completedAt || undefined;

    const updatedTask = await updateTask(id, taskUpdates);

    if (!updatedTask) {
      return NextResponse.json({ error: 'Task not found or update failed' }, { status: 404 });
    }

    return NextResponse.json({ task: updatedTask });
  } catch (error) {
    console.error('Error in PATCH /api/tasks:', error);
    return NextResponse.json({ error: 'Failed to update task' }, { status: 500 });
  }
}

/**
 * DELETE /api/tasks
 * Delete a task
 *
 * Query params:
 * - id: string (required) - Task ID to delete (must be UUID)
 */
export async function DELETE(request: NextRequest) {
  try {
    // Verify user is authenticated
    const authResult = await requireAuth(request);
    if (isAuthError(authResult)) {
      return authResult;
    }

    const { searchParams } = new URL(request.url);
    const taskId = searchParams.get('id');

    if (!taskId) {
      return NextResponse.json({ error: 'Task ID is required' }, { status: 400 });
    }

    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(taskId)) {
      return NextResponse.json({ error: 'Invalid task ID format' }, { status: 400 });
    }

    const success = await deleteTask(taskId);

    if (!success) {
      return NextResponse.json({ error: 'Task not found or delete failed' }, { status: 404 });
    }

    return NextResponse.json({ success: true, id: taskId });
  } catch (error) {
    console.error('Error in DELETE /api/tasks:', error);
    return NextResponse.json({ error: 'Failed to delete task' }, { status: 500 });
  }
}
